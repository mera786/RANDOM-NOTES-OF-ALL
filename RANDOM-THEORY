                                                           EQUALS & HASHCODE 

ğŸ”´ Case 1: You do NOT override equals() and hashCode() :
-----------------------------------------------------------
Since neither equals() nor hashCode() is overridden, Java uses the default implementations from Object class:
equals() compares object references (p1 == p2)
hashCode() is based on the objectâ€™s memory address
âœ… Result:
Both p1 and p2 are considered different, even if they contain the same data â†’ both get added to the set.

ğŸŸ¡ Case 2: You override only equals() but NOT hashCode()
------------------------------------------------------------
ğŸ§  What happens?
equals() says the objects are equal based on data (like name and age)
But hashCode() still gives different hash codes (default from Object)
âš ï¸ Consequence:
HashSet uses hashCode() first to locate bucket.
Since hash codes are different â†’ it puts them in different buckets â†’ equals() is never even called.
âœ… Result:
Still both objects are stored, even though logically they are equal.

ğŸŸ  Case 3: You override only hashCode() but NOT equals()
---------------------------------------------------------
ğŸ§  What happens?
Both objects now have the same hash code (great!)
But equals() still checks reference equality (from Object)
âœ… Result:
Java finds the same bucket (due to same hash code)
So both objects get added to the same bucket but as different entries.

                                                             HASHMAP 

âœ… Scenario 1: Same key, same value inserted twice
Input:
map.put(1, "Apple");
map.put(1, "Apple");
Explanation:
You are inserting the same key 1 with the same value "Apple" twice.
In Java's HashMap, keys must be unique.
So the second put() will overwrite the existing entry, but since the value is the same, nothing actually changes.
becasue It uses hashCode() to find the bucket, then equals() to compare the key.
Since the key already exists, it updates the existing entry.
Output:
{1=Apple}
But when it compares them, equals() says they're different â†’ both are added

âœ… Scenario 2: Same key, different value inserted
Input:
map.put(1, "Apple");
map.put(1, "Banana");
Explanation:
The second put() uses the same key 1 but with a different value "Banana".
This replaces the old value ("Apple") with the new one ("Banana").
Output:
{1=Banana}

There are 7+ ways to print a HashMap :::::
-------------------------------------------
âœ… 1. Direct print

System.out.println(map);
Note:Prints the whole map in {key=value} format.


âœ… 2. Using entrySet() with a for-each loop

for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " => " + entry.getValue());
}


âœ… 3. Using keySet() and get()

for (Integer key : map.keySet()) {
    System.out.println(key + " => " + map.get(key));
}


âœ… 4. Using values()

for (String value : map.values()) {
    System.out.println("Value: " + value);
}


âœ… 5. Using forEach() method (Java 8+)

map.forEach((key, value) -> System.out.println(key + " => " + value));


âœ… 6. Using Iterator on entrySet()

Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    System.out.println(entry.getKey() + " => " + entry.getValue());
}




