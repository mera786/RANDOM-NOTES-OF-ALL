                                                           EQUALS & HASHCODE 

üî¥ Case 1: You do NOT override equals() and hashCode() :
-----------------------------------------------------------
Since neither equals() nor hashCode() is overridden, Java uses the default implementations from Object class:
equals() compares object references (p1 == p2)
hashCode() is based on the object‚Äôs memory address
‚úÖ Result:
Both p1 and p2 are considered different, even if they contain the same data ‚Üí both get added to the set.

üü° Case 2: You override only equals() but NOT hashCode()
------------------------------------------------------------
üß† What happens?
equals() says the objects are equal based on data (like name and age)
But hashCode() still gives different hash codes (default from Object)
‚ö†Ô∏è Consequence:
HashSet uses hashCode() first to locate bucket.
Since hash codes are different ‚Üí it puts them in different buckets ‚Üí equals() is never even called.
‚úÖ Result:
Still both objects are stored, even though logically they are equal.

üü† Case 3: You override only hashCode() but NOT equals()
---------------------------------------------------------
üß† What happens?
Both objects now have the same hash code (great!)
But equals() still checks reference equality (from Object)
‚úÖ Result:
Java finds the same bucket (due to same hash code)
So both objects get added to the same bucket but as different entries.

                                                             HASHMAP 

‚úÖ Scenario 1: Same key, same value inserted twice
Input:
map.put(1, "Apple");
map.put(1, "Apple");
Explanation:
You are inserting the same key 1 with the same value "Apple" twice.
In Java's HashMap, keys must be unique.
So the second put() will overwrite the existing entry, but since the value is the same, nothing actually changes.
becasue It uses hashCode() to find the bucket, then equals() to compare the key.
Since the key already exists, it updates the existing entry.
Output:
{1=Apple}
But when it compares them, equals() says they're different ‚Üí both are added

‚úÖ Scenario 2: Same key, different value inserted
Input:
map.put(1, "Apple");
map.put(1, "Banana");
Explanation:
The second put() uses the same key 1 but with a different value "Banana".
This replaces the old value ("Apple") with the new one ("Banana").
Output:
{1=Banana}

There are 7+ ways to print a HashMap :::::
-------------------------------------------
‚úÖ 1. Direct print

System.out.println(map);
Note:Prints the whole map in {key=value} format.


‚úÖ 2. Using entrySet() with a for-each loop

for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " => " + entry.getValue());
}


‚úÖ 3. Using keySet() and get()

for (Integer key : map.keySet()) {
    System.out.println(key + " => " + map.get(key));
}


‚úÖ 4. Using values()

for (String value : map.values()) {
    System.out.println("Value: " + value);
}


‚úÖ 5. Using forEach() method (Java 8+)

map.forEach((key, value) -> System.out.println(key + " => " + value));


‚úÖ 6. Using Iterator on entrySet()

Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    System.out.println(entry.getKey() + " => " + entry.getValue());
}


                                                 ‚úÖ Java Casting Scenarios :

| #  | Java Code                                             | Description                       | Valid? | Notes                                                |
| -- | ----------------------------------------------------- | --------------------------------- | ------ | ---------------------------------------------------- |
| 1  | `Child c = new Child();`                              | Regular object creation           | ‚úÖ      | Normal usage, full access to `Child` methods         |
| 2  | `Parent p = new Parent();`                            | Regular parent object             | ‚úÖ      | Only `Parent` methods, no polymorphism               |
| 3  | `Parent p = new Child();`                             | Upcasting (implicit)              | ‚úÖ      | Allowed. You can access only `Parent` methods        |
| 4  | `Child c = (Child) new Child();`                      | Downcasting, same type            | ‚úÖ      | Safe cast, as object is already a `Child`            |
| 5  | `Child c = (Child) new Parent();`                     | Invalid downcasting               | ‚ùå      | Compiles, but throws `ClassCastException` at runtime |
| 6  | `Parent p = new Child();`<br>`Child c = (Child) p;`   | Downcasting from parent reference | ‚úÖ      | Safe because object is actually a `Child`            |
| 7  | `Parent p = new Parent();`<br>`Child c = (Child) p;`  | Invalid downcast from parent      | ‚ùå      | Fails at runtime: not truly a `Child`                |
| 8  | `Object o = new Child();`<br>`Parent p = (Parent) o;` | Cast from Object ‚Üí Parent         | ‚úÖ      | Allowed                                              |
| 9  | `Object o = new Parent();`<br>`Child c = (Child) o;`  | Cast Object ‚Üí Child (invalid)     | ‚ùå      | Runtime error: not actually a `Child`                |
| 10 | `Object o = new Child();`<br>`Child c = (Child) o;`   | Cast Object ‚Üí Child               | ‚úÖ      | Allowed if object is truly `Child`      
|

For safe Casting : always use,
if (p instanceof Child) {
    Child c = (Child) p; // ‚úÖ Safe
}


