                                                           EQUALS & HASHCODE 

ğŸ”´ Case 1: You do NOT override equals() and hashCode() :
-----------------------------------------------------------
Since neither equals() nor hashCode() is overridden, Java uses the default implementations from Object class:
equals() compares object references (p1 == p2)
hashCode() is based on the objectâ€™s memory address
âœ… Result:
Both p1 and p2 are considered different, even if they contain the same data â†’ both get added to the set.

ğŸŸ¡ Case 2: You override only equals() but NOT hashCode()
------------------------------------------------------------
ğŸ§  What happens?
equals() says the objects are equal based on data (like name and age)
But hashCode() still gives different hash codes (default from Object)
âš ï¸ Consequence:
HashSet uses hashCode() first to locate bucket.
Since hash codes are different â†’ it puts them in different buckets â†’ equals() is never even called.
âœ… Result:
Still both objects are stored, even though logically they are equal.

ğŸŸ  Case 3: You override only hashCode() but NOT equals()
---------------------------------------------------------
ğŸ§  What happens?
Both objects now have the same hash code (great!)
But equals() still checks reference equality (from Object)
âœ… Result:
Java finds the same bucket (due to same hash code)
But when it compares them, equals() says they're different â†’ both are added
